apiVersion: v1
kind: ServiceAccount
metadata:
  name: kasten-test-sa
  namespace: kasten-io
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kasten-test-role
rules:
- apiGroups: [""]
  resources: ["pods", "services", "namespaces", "configmaps"]
  verbs: ["get", "list", "watch", "create"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "watch", "create"]
- apiGroups: [""]
  resources: ["persistentvolumeclaims"]
  verbs: ["get", "list", "watch", "create"]
- apiGroups: ["config.kio.kasten.io"]
  resources: ["policies"]
  verbs: ["get", "list", "watch", "create"]
- apiGroups: ["actions.kio.kasten.io"]
  resources: ["runs"]
  verbs: ["get", "list", "watch", "create"]
- apiGroups: ["apps.kio.kasten.io"]
  resources: ["applications"]
  verbs: ["get", "list", "watch", "create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kasten-test-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kasten-test-role
subjects:
- kind: ServiceAccount
  name: kasten-test-sa
  namespace: kasten-io
---
apiVersion: source.toolkit.fluxcd.io/v1beta2
kind: HelmRepository
metadata:
  name: pacman-repo
  namespace: kasten-io
spec:
  interval: 1h
  url: https://github.com/shuguet/pacman/raw/main/charts/
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: kasten-tester
  namespace: kasten-io
spec:
  schedule: "0 0 * * *"  # Run daily at midnight
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: kasten-test-sa
          containers:
          - name: kasten-test
            image: bitnami/kubectl:latest
            command:
            - /bin/bash
            - -c
            - |
              # Install helm
              echo "Installing Helm..."
              curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
              
              # Add Pacman Helm repo
              echo "Adding Pacman Helm repository..."
              helm repo add pacman https://github.com/shuguet/pacman/raw/main/charts/ || {
                echo "Failed to add Pacman Helm repository"
                exit 1
              }
              helm repo update
              
              # Wait for Kasten to be fully deployed
              echo "Waiting for Kasten K10 to be ready..."
              kubectl wait --for=condition=ready pod -l component=catalog -n kasten-io --timeout=300s || {
                echo "Kasten K10 not ready within timeout"
                exit 1
              }
              
              # Create namespace for Pacman application
              echo "Creating pacman namespace..."
              cat <<EOF | kubectl apply -f -
              apiVersion: v1
              kind: Namespace
              metadata:
                name: pacman
                labels:
                  aws.conformance.vendor: veeam
                  aws.conformance.vendor-solution: kasten-test
              EOF
              
              # Install Pacman application using Helm chart
              echo "Installing Pacman application using Helm..."
              helm install pacman pacman/pacman -n pacman \
                --set mongodb.persistence.storageClass=ebs-sc \
                --set mongodb.persistence.size=2Gi || {
                echo "Failed to install Pacman application"
                exit 1
              }
              
              # Wait for Pacman application to be ready
              echo "Waiting for Pacman application to be ready..."
              kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=mongodb -n pacman --timeout=300s || {
                echo "MongoDB pod not ready within timeout"
                exit 1
              }
              kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=pacman -n pacman --timeout=300s || {
                echo "Pacman pod not ready within timeout"
                exit 1
              }
              
              # Create the Kasten backup policy
              echo "Creating Kasten backup policy..."
              cat <<EOF | kubectl apply -f -
              apiVersion: config.kio.kasten.io/v1alpha1
              kind: Policy
              metadata:
                name: pacman-backup-policy
                namespace: kasten-io
              spec:
                comment: "Policy to backup Pacman application"
                frequency: "@never"
                actions:
                  - action: backup
                    backupParameters:
                      filters: {}
                selector:
                  matchExpressions:
                    - key: k10.kasten.io/appNamespace
                      operator: In
                      values:
                        - pacman
              EOF
              
              # Create application profile for Pacman
              echo "Creating application profile for Pacman..."
              cat <<EOF | kubectl apply -f - 
              apiVersion: apps.kio.kasten.io/v1alpha1
              kind: Application
              metadata:
                name: pacman
                namespace: kasten-io
              spec:
                workloads:
                  namespaces:
                  - pacman
              EOF
              
              # Run backup policy once
              echo "Running backup policy..."
              cat <<EOF | kubectl apply -f -
              apiVersion: actions.kio.kasten.io/v1alpha1
              kind: Run
              metadata:
                generateName: pacman-backup-policy-
                namespace: kasten-io
              spec:
                subject:
                  kind: Policy
                  name: pacman-backup-policy
                  namespace: kasten-io
              EOF
              
              # Wait for the backup job to complete
              echo "Waiting for backup job to complete..."
              sleep 30
              
              # Get the latest run and check its status
              LATEST_RUN=$(kubectl get runs -n kasten-io -l action=backup -o jsonpath='{.items[-1:].metadata.name}')
              echo "Checking status of run: $LATEST_RUN"
              
              # Wait for the run to complete (not running)
              RETRY=0
              MAX_RETRIES=12
              
              while true; do
                STATE=$(kubectl get run $LATEST_RUN -n kasten-io -o jsonpath='{.status.state}')
                if [ "$STATE" != "Running" ] && [ "$STATE" != "" ]; then
                  echo "Run completed with state: $STATE"
                  break
                fi
                
                RETRY=$((RETRY+1))
                if [ $RETRY -ge $MAX_RETRIES ]; then
                  echo "Timed out waiting for backup to complete"
                  exit 1
                fi
                
                echo "Backup still in progress, waiting... (attempt $RETRY/$MAX_RETRIES)"
                sleep 30
              done
              
              # Check if backup was successful
              if [ "$STATE" == "Complete" ]; then
                echo "Backup completed successfully!"
                exit 0
              else
                echo "Backup failed with state: $STATE"
                exit 1
              fi
          restartPolicy: OnFailure